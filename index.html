<html>

<head>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
    }

    .board {
      display: grid;
      aspect-ratio: 1;
      width: 50%;
      /* The repeat() notation accepts 2 arguments: the first represents the
        number of times the defined tracks should repeat, and the second is 
        the track definition. */
      grid-template-rows: repeat(50, auto);
      grid-template-columns: repeat(50, auto);

      /* prevents scroll/drag */
      touch-action: none;
    }

    .scoreboard {
      border: 1px solid white;
      color: white;
      font-family: monospace;
      font-weight: bold;
      left: 0;
      position: absolute;
      top: 0;
    }

    .board>div {
      border: 1px solid black;
      border-top: 0;
      border-left: 0;
      box-sizing: border-box;
    }

    .empty {
      background-color: black;
    }

    .snake {
      background-color: limegreen;
      /* animation-duration: 250ms;
      animation-name: snakehead; */
    }

    .apple {
      background-color: red;
    }

    @keyframes snakehead {
      from {
        transform: scale(1.5);
      }

      to {
        transform: scale(1);
      }
    }

  </style>
  <script type="module">

    /**
     * todo: high score,
     * 
     * handle a variable game tick speed; set update loop at max speed (e.g. 16ms)
     * keep track of ms since last tick completion; 
     * `const now = performance.now();`
     * `if (now - prevTime < desiredUpdateDuration) return;`
     * `prevTime = now`
     */

    class Game {
      constructor() {
        // our grid contains simple integers to represent game objects;
        // this map translates the numbers to a string, that can then be used as
        // human-readable reference or CSS class (for display purposes)
        this.valueMap = {
          0: 'empty',
          1: 'snake',
          2: 'apple'
        };

        this.rowCount = 50;
        this.columnCount = 50;

        // set initial board state as empty
        this.state = Array(this.rowCount * this.columnCount).fill(null);

        // set up DOM references
        let boardRef = document.querySelector('section.board');
        this.gridRef = [];

        this.state.forEach(i => {
          let node = document.createElement('div');
          this.gridRef.push(node);
          boardRef.appendChild(node);
        });

        let nextState = [...this.state];

        // set initial background
        nextState.fill(0);

        // set up initial snake position
        this.snake = {
          position: [1275, 1274, 1273, 1272],
          direction: 'right'
        };

        // draw the snaaake
        this.snake.position.forEach(index => nextState[index] = 1);

        // create some random APPLES
        for (let i = 0; i < 10; i += 1) {
          nextState = this.makeApple(nextState);
        }

        // do initial draw
        this.render(nextState);

        this.score = 0;
        this.renderScore();

        // bind context variable to the current Game() object
        // for each of these global handlers/interval

        // add global keyboard handler
        window.addEventListener('keydown', this.onKeyDown.bind(this));

        // add touch event handler
        window.addEventListener('touchstart', this.onTouchStart.bind(this));
        window.addEventListener('touchend', this.onTouchEnd.bind(this));

        // update loop every second
        this.interval = window.setInterval(this.update.bind(this), 50);
      }

      makeApple(cells) {
        let rando = Math.floor(Math.random() * this.columnCount * this.rowCount);

        // ensure placement in empty spot
        while (cells[rando] !== 0) {
          rando = Math.floor(Math.random() * this.columnCount * this.rowCount);
        }

        // place the apple
        cells[rando] = 2;

        return cells;
      }

      ArrowLeft() {
        // can't go the opposite direction, or else you'd immediately crash
        if (this.snake.direction !== 'right') {
          this.snake.direction = 'left';
        }
      }

      ArrowRight() {
        // can't go the opposite direction, or else you'd immediately crash
        if (this.snake.direction !== 'left') {
          this.snake.direction = 'right';
        }
      }

      ArrowUp() {
        // can't go the opposite direction, or else you'd immediately crash
        if (this.snake.direction !== 'down') {
          this.snake.direction = 'up';
        }
      }

      ArrowDown() {
        // can't go the opposite direction, or else you'd immediately crash
        if (this.snake.direction !== 'up') {
          this.snake.direction = 'down';
        }
      }

      dumpState() {
        for (let row = 0; row < this.rowCount; row += 1) {
          // TODO: console.table?
          console.log(this.state.slice(row * this.columnCount, row * this.columnCount + this.columnCount))
        }
      }

      onKeyDown(event) {
        // If the `Game` component has a defined method that
        // is equal to the name of the pressed key...
        if (typeof this[event.key] === 'function') {
          // fire that method
          this[event.key]();

          event.preventDefault();
        }
      }

      onTouchStart(e) {
        // store where the player first touched the screen
        this.currentTouch = e.changedTouches[0];  // only care about the first touch
      }

      onTouchEnd(e) {
        // store local ref to last touch
        const endTouch = e.changedTouches[0];

        let xDiff = endTouch.clientX - this.currentTouch.clientX;
        let yDiff = endTouch.clientY - this.currentTouch.clientY;

        // horizontal touch direction was greater
        if (Math.abs(xDiff) > Math.abs(yDiff)) {
          // user moved their finger (mostly) right
          if (xDiff > 0) {
            this.ArrowRight();
          } else {
            this.ArrowLeft();
          }
          // vertical touch direction was greater
        } else {
          // user moved their finger (mostly) down
          if (yDiff > 0) {
            this.ArrowDown();
          } else {
            this.ArrowUp();
          }
        }
      }

      update() {
        let cells = [...this.state]; // shallow clone

        // find next position
        let newSnakeHeadIndex;

        switch (this.snake.direction) {
          case 'right':
            newSnakeHeadIndex = this.snake.position[0] + 1;
            break;
          case 'left':
            newSnakeHeadIndex = this.snake.position[0] - 1;
            break;
          case 'up':
            newSnakeHeadIndex = this.snake.position[0] - this.columnCount;
            break;
          case 'down':
            newSnakeHeadIndex = this.snake.position[0] + this.columnCount;
            break;
        }

        // handle screen wrap
        if (newSnakeHeadIndex > this.rowCount * this.columnCount) {
          newSnakeHeadIndex -= this.rowCount * this.columnCount;
        }

        if (newSnakeHeadIndex < 0) {
          newSnakeHeadIndex += this.rowCount * this.columnCount;
        }

        // check for body collision
        if (cells[newSnakeHeadIndex] === 1) {
          window.alert('u lose');

          // stop the update loop
          clearInterval(this.interval);

          return;
        }

        // clear snake's current position
        this.snake.position.forEach(index => cells[index] = 0);

        // check for apple collision
        if (cells[newSnakeHeadIndex] === 2) {
          // if the snake eats an apple, turn the apple into the new "head"
          // so the snake grows
          this.snake.position.unshift(newSnakeHeadIndex);

          this.score += 1;
          this.renderScore();

          // make a new apple
          cells = this.makeApple(cells);
        } else {
          // otherwise, shift the whole snake body
          for (let i = this.snake.position.length - 1; i >= 1; i -= 1) {
            // give each body segment the position of the one before it
            this.snake.position[i] = this.snake.position[i - 1];
          }

          // finally, move the head
          this.snake.position[0] = newSnakeHeadIndex;
        }

        // draw the snaaake
        this.snake.position.forEach(index => cells[index] = 1);

        // update display
        this.render(cells);
      }

      renderScore() {
        document.querySelector('.scoreboard').textContent = this.score;
      }

      render(nextState) {
        // get diff between current state/next state
        let diffIndices = this.state.reduce((accumulator, currentValue, index) => {
          let nextValue = nextState[index]
          if (nextValue !== currentValue) {
            accumulator.push(index);
          }
          return accumulator;
        }, []);

        // update DOM references
        diffIndices.forEach(index => this.gridRef[index].classList = this.valueMap[nextState[index]]);

        // set the next state as current state
        this.state = nextState;
      }
    };

    new Game()
  </script>
</head>

<body>
  <div class="game">
    <section class="board"></section>
    <section class="scoreboard"></section>
  </div>
</body>

</html>
